PARTITION LABELS - VISUAL WALKTHROUGH & DEEP DIVE
==================================================

PROBLEM VISUALIZATION
=====================

Goal: Split string so each character appears in only ONE partition
Maximize number of partitions

Example: s = "ababcbaca"

Visual representation of character positions:
Position: 0 1 2 3 4 5 6 7 8
String:   a b a b c b a c a
          â†‘       â†‘     â†‘ â†‘   'a' appears here
            â†‘   â†‘   â†‘ â†‘       'b' appears here
                â†‘     â†‘ â†‘     'c' appears here

Character ranges (first â†’ last):
'a': [0 â†’ 8]  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
'b': [1 â†’ 7]    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
'c': [4 â†’ 8]            â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

All ranges overlap! Must be ONE partition: [0, 8]
Result: [9]  (one partition of size 9)


EXAMPLE 2: s = "ababcbacadefegde"

Position: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
String:   a b a b c b a c a d e  f  e  g  d  e
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          Partition 1 (size 9) Partition 2 (size 7)

Character ranges:
'a': [0 â†’ 8]  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
'b': [1 â†’ 7]    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
'c': [4 â†’ 8]            â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
'd': [9 â†’ 14]                      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
'e': [10 â†’ 15]                       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
'f': [11 â†’ 11]                         â–ˆâ–ˆ
'g': [13 â†’ 13]                             â–ˆâ–ˆ

First group overlaps: [0-8]
Second group overlaps: [9-15]
Result: [9, 7]


THE GREEDY ALGORITHM - STEP BY STEP
====================================

Key insight: As we scan left to right, track the furthest we MUST go

Think of it like this:
- Start at position 0
- "How far must I go to include all 'a's?" â†’ position 8
- "At position 1, found 'b'. How far for all 'b's?" â†’ position 7 (< 8, OK)
- "At position 4, found 'c'. How far for all 'c's?" â†’ position 8 (same)
- Continue until position 8
- At position 8: we've seen all occurrences of a, b, c â†’ CUT HERE!


DETAILED TRACE - "ababcbaca"
=============================

Last occurrences precomputed:
last['a'] = 8
last['b'] = 7
last['c'] = 8

Scanning process:

Position 0: char='a'
  Current partition: [0, ?]
  Must extend to: position 8 (last 'a')
  partitionEnd = 8
  
  Visual:
  a b a b c b a c a
  ^â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ must reach here
  â””â”€start

Position 1: char='b'
  Current partition: [0, ?]
  Must extend to: position 7 (last 'b')
  partitionEnd = max(8, 7) = 8 (no change)
  
  Visual:
  a b a b c b a c a
  ^â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ still must reach position 8
  â””â”€start

Position 2: char='a'
  partitionEnd = max(8, 8) = 8 (no change)

Position 3: char='b'
  partitionEnd = max(8, 7) = 8 (no change)

Position 4: char='c'
  Must extend to: position 8 (last 'c')
  partitionEnd = max(8, 8) = 8 (no change)

Position 5: char='b'
  partitionEnd = max(8, 7) = 8 (no change)

Position 6: char='a'
  partitionEnd = max(8, 8) = 8 (no change)

Position 7: char='c'
  partitionEnd = max(8, 8) = 8 (no change)

Position 8: char='a'
  partitionEnd = max(8, 8) = 8
  
  CRITICAL: position 8 == partitionEnd!
  We've reached the end of partition!
  
  Partition complete: [0, 8] = "ababcbaca"
  Size: 8 - 0 + 1 = 9
  
  Add to result: [9]
  
  Visual:
  a b a b c b a c a |
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  Partition 1 (size 9)

Since we're at the end, we're done!
Result: [9]


COMPLEX EXAMPLE - "ababcbacadefegde"
====================================

Last occurrences:
aâ†’8, bâ†’7, câ†’8, dâ†’14, eâ†’15, fâ†’11, gâ†’13

Scanning:

Positions 0-8: Building first partition
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
i=0: 'a', partitionEnd=8
i=1: 'b', partitionEnd=8 (max(8,7))
i=2: 'a', partitionEnd=8
i=3: 'b', partitionEnd=8
i=4: 'c', partitionEnd=8
i=5: 'b', partitionEnd=8
i=6: 'a', partitionEnd=8
i=7: 'c', partitionEnd=8
i=8: 'a', partitionEnd=8, i==partitionEnd âœ“

First partition: [0,8] = "ababcbaca", size=9

Visual:
a b a b c b a c a | d e f e g d e
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Partition 1

Positions 9-15: Building second partition
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
i=9:  'd', partitionEnd=14, partitionStart=9
i=10: 'e', partitionEnd=15 (max(14,15)) â† Extended!
i=11: 'f', partitionEnd=15 (max(15,11))
i=12: 'e', partitionEnd=15
i=13: 'g', partitionEnd=15 (max(15,13))
i=14: 'd', partitionEnd=15
i=15: 'e', partitionEnd=15, i==partitionEnd âœ“

Second partition: [9,15] = "defegde", size=7

Visual:
a b a b c b a c a | d e f e g d e
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Partition 1          Partition 2

Result: [9, 7]


WHY THE GREEDY APPROACH WORKS
==============================

Proof by contradiction:
-----------------------
Suppose greedy doesn't give maximum partitions.

Then there exists a better solution that cuts earlier.

Say greedy cuts at position k, but optimal cuts at position j < k.

At position j:
- greedy found partitionEnd > j (otherwise it would have cut)
- This means some character c at position â‰¤ j has last occurrence > j
- Character c appears both before and after position j
- Therefore, cutting at j violates the constraint!
- Contradiction!

Therefore, greedy gives maximum partitions. âœ“


INTERVAL MERGING PERSPECTIVE
=============================

Alternative way to think about it:

1. Each character defines an interval [first_pos, last_pos]
2. Overlapping intervals must be merged
3. Count the merged intervals

Example: "ababcbaca"

Intervals:
a: [0, 8]  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
b: [1, 7]    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
c: [4, 8]            â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

Merging:
[0, 8] overlaps with [1, 7] â†’ merge to [0, 8]
[0, 8] overlaps with [4, 8] â†’ stays [0, 8]

Final: One interval [0, 8]
Result: [9] (size of interval)


Example: "abcdef"

Intervals:
a: [0, 0]  â–ˆâ–ˆ
b: [1, 1]    â–ˆâ–ˆ
c: [2, 2]      â–ˆâ–ˆ
d: [3, 3]        â–ˆâ–ˆ
e: [4, 4]          â–ˆâ–ˆ
f: [5, 5]            â–ˆâ–ˆ

No overlaps!
Final: Six intervals
Result: [1, 1, 1, 1, 1, 1]


EDGE CASE ANALYSIS
==================

Case 1: Single character
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
s = "a"
last['a'] = 0
i=0: partitionEnd=0, i==0 âœ“
Result: [1]


Case 2: All same character
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
s = "aaaa"
last['a'] = 3

i=0: partitionEnd=3
i=1: partitionEnd=3
i=2: partitionEnd=3
i=3: partitionEnd=3, i==3 âœ“

Result: [4]


Case 3: All different characters
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
s = "abcdef"
last['a']=0, last['b']=1, last['c']=2, etc.

i=0: 'a', partitionEnd=0, i==0 âœ“ â†’ [1]
i=1: 'b', partitionEnd=1, i==1 âœ“ â†’ [1]
i=2: 'c', partitionEnd=2, i==2 âœ“ â†’ [1]
i=3: 'd', partitionEnd=3, i==3 âœ“ â†’ [1]
i=4: 'e', partitionEnd=4, i==4 âœ“ â†’ [1]
i=5: 'f', partitionEnd=5, i==5 âœ“ â†’ [1]

Result: [1, 1, 1, 1, 1, 1] â† Maximum partitions!


Case 4: Completely interleaved
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
s = "aba"
last['a']=2, last['b']=1

i=0: 'a', partitionEnd=2
i=1: 'b', partitionEnd=2 (max(2,1))
i=2: 'a', partitionEnd=2, i==2 âœ“

Result: [3] â† Must be one partition


Case 5: Pattern with clear split
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
s = "aabbccdd"
last['a']=1, last['b']=3, last['c']=5, last['d']=7

i=0: 'a', partitionEnd=1
i=1: 'a', partitionEnd=1, i==1 âœ“ â†’ [2]
i=2: 'b', partitionEnd=3
i=3: 'b', partitionEnd=3, i==3 âœ“ â†’ [2]
i=4: 'c', partitionEnd=5
i=5: 'c', partitionEnd=5, i==5 âœ“ â†’ [2]
i=6: 'd', partitionEnd=7
i=7: 'd', partitionEnd=7, i==7 âœ“ â†’ [2]

Result: [2, 2, 2, 2]

Visual:
a a | b b | c c | d d
â””â”€â”˜   â””â”€â”˜   â””â”€â”˜   â””â”€â”˜
 2     2     2     2


COMPLEXITY ANALYSIS
===================

Time Complexity: O(n)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
- First pass: Find last occurrences â†’ O(n)
- Second pass: Build partitions â†’ O(n)
- Total: O(n) + O(n) = O(n)

Space Complexity: O(1)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
- Last occurrence array: 26 entries â†’ O(1)
- Result list: O(k) where k = number of partitions
  - Best case: O(1) (one partition)
  - Worst case: O(n) (n partitions, all different chars)
  - But this is required output, not auxiliary space
- Auxiliary space: O(1)

Can we do better?
- Time: No! Must read entire string â†’ Î©(n)
- Space: No! 26 is already constant


COMMON MISTAKES - VISUAL EXAMPLES
==================================

Mistake 1: Cutting too early
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
s = "abccba"

âŒ WRONG: Cut after first 'a'
a | b c c b a
â””â”€â”˜
  â””â”€â”€â”€ 'a' appears here too! INVALID!

âœ“ CORRECT: Must extend to last 'a'
a b c c b a
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
One partition


Mistake 2: Wrong partition size calculation
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
s = "abc"

Position: 0 1 2
String:   a b c

âŒ result.add(partitionEnd) â†’ [0, 1, 2] WRONG!
âŒ result.add(i) â†’ [0, 1, 2] WRONG!
âœ“  result.add(partitionEnd - partitionStart + 1) â†’ [1, 1, 1] âœ“


Mistake 3: Not updating partition start
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
After cutting first partition:

âŒ WRONG: Keep partitionStart = 0
  Next size = partitionEnd - 0 + 1 (includes first partition!)

âœ“ CORRECT: partitionStart = i + 1
  Next size = partitionEnd - (i+1) + 1 (only new partition)


Mistake 4: Using < instead of ==
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âŒ WRONG: if (i < partitionEnd)
  Never cuts! Always waiting for MORE

âœ“ CORRECT: if (i == partitionEnd)
  Cuts exactly when we've covered the partition


INTERVIEW DIALOGUE EXAMPLE
===========================

Interviewer: "Partition the string into maximum parts where each 
             character appears in at most one part."

You: "Let me make sure I understand. For 'ababcc', I could partition
     it as ['abab', 'cc'] where 'a' and 'b' only appear in first part,
     and 'c' only appears in second part. Is that correct?"

Interviewer: "Yes, exactly."

You: "And I want to maximize the number of partitions?"

Interviewer: "Correct."

You: "I see. This is a greedy problem. The key insight is that for each
     character, I need to know where it last appears. Then as I scan the
     string, I keep extending my partition boundary to include all 
     occurrences of characters I've seen."

You: "Let me trace through 'ababcc':
     - First, I'll find last occurrences: aâ†’2, bâ†’3, câ†’5
     - Start at position 0, char='a', must reach position 2
     - Position 1, char='b', must reach position 3 (extend!)
     - Position 2, char='a', must reach position 2 (no change)
     - Position 3, char='b', must reach position 3, and we're here! Cut.
     - First partition: [0,3] = 'abab', size 4
     - Position 4, char='c', must reach position 5
     - Position 5, char='c', must reach position 5, and we're here! Cut.
     - Second partition: [4,5] = 'cc', size 2
     - Result: [4, 2]"

Interviewer: "Good! What's the time complexity?"

You: "O(n) - one pass to find last occurrences, one pass to build 
     partitions. Space is O(1) since we only track 26 possible characters."

Interviewer: "Can you code it?"

You: "Sure!" [Codes the solution]


PATTERN RECOGNITION
===================

This problem is similar to:

âœ“ Merge Intervals (LC 56)
  - Both involve merging overlapping ranges
  - Difference: Here we build ranges dynamically

âœ“ Non-overlapping Intervals (LC 435)
  - Both use greedy approach for intervals
  - Difference: Here we partition, there we remove

âœ“ Jump Game II (LC 45)
  - Both track "furthest reachable" position
  - Similar greedy strategy

Common pattern: Greedy + Range tracking


SUMMARY
=======

Algorithm:
1. Find last occurrence of each character â†’ O(n)
2. Scan string, extending partition boundary â†’ O(n)
3. Cut when current position reaches boundary
4. Repeat until end

Key insights:
âœ“ Greedy approach works (proven correct)
âœ“ Track furthest we must go
âœ“ Cut as soon as possible (maximize partitions)
âœ“ Think of it as interval merging

Complexity:
âœ“ Time: O(n) - optimal
âœ“ Space: O(1) - only 26 characters

This problem combines:
- Greedy algorithms
- Interval processing  
- Range tracking
- Array indexing

Good luck! ğŸ¯
