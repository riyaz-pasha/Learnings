# 1ï¸âƒ£ What is a Monotonic Stack?

A **monotonic stack** is a stack that maintains its elements in a **specific order**:

* **Monotonically increasing stack**

  * Elements increase from bottom â†’ top
  * Example: `2, 5, 8`
* **Monotonically decreasing stack**

  * Elements decrease from bottom â†’ top
  * Example: `9, 6, 3`

ğŸ‘‰ The stack is **not fully sorted**, but it preserves monotonic order based on how we **push and pop**.

---

# 2ï¸âƒ£ Next Greater Element (NGE) â€” Problem Restated

> For every element in the array, find the **first element to its right** that is **strictly greater**.

Example:

```
Input:  [4, 5, 2, 10, 8]
Output: [5, 10, 10, -1, -1]
```

---

# 3ï¸âƒ£ Brute Force (Why We Need Monotonic Stack)

Brute force idea:

* For each element, scan right side until you find a greater element.

â± Time Complexity:

```
O(n^2)
```

This is **too slow** for large inputs.

---

# 4ï¸âƒ£ Key Insight Behind Monotonic Stack

### Instead of repeatedly scanning right,

### ğŸ‘‰ **use a stack to remember "useful candidates"**

When processing elements:

* If a **new element is greater**, it becomes the **next greater element** for all **smaller elements waiting in the stack**.

So:

* Stack holds elements **whose NGE is not yet found**
* Once we find a greater element â†’ resolve them

---

# 5ï¸âƒ£ Which Monotonic Stack for NGE?

### ğŸ”¥ We use a **Monotonically Decreasing Stack**

Why?

* We want the **next greater element**
* Smaller elements should wait for a bigger one
* So stack keeps elements in **decreasing order**

Example stack state:

```
Top
 â†“
[5]
[7]
[10]
```

(From bottom â†’ top: 10 > 7 > 5)

---

# 6ï¸âƒ£ Step-by-Step Algorithm (Left â†’ Right)

For each element `arr[i]`:

1. While stack is **not empty** AND
   `stack.top() < arr[i]`

   * Pop the stack
   * For the popped element, `arr[i]` is its **Next Greater Element**
2. Push `arr[i]` into the stack
3. After traversal:

   * Remaining stack elements â†’ no greater element â†’ `-1`

---

# 7ï¸âƒ£ Dry Run Example

Input:

```
arr = [4, 5, 2, 10, 8]
```

### Initialize:

```
Stack = empty
Result = [-1, -1, -1, -1, -1]
```

---

### i = 0 â†’ 4

```
Stack empty â†’ push 4
Stack: [4]
```

---

### i = 1 â†’ 5

```
5 > 4 â†’ pop 4 â†’ NGE[4] = 5
Push 5
Stack: [5]
```

---

### i = 2 â†’ 2

```
2 < 5 â†’ push 2
Stack: [5, 2]
```

---

### i = 3 â†’ 10

```
10 > 2 â†’ pop 2 â†’ NGE[2] = 10
10 > 5 â†’ pop 5 â†’ NGE[5] = 10
Push 10
Stack: [10]
```

---

### i = 4 â†’ 8

```
8 < 10 â†’ push 8
Stack: [10, 8]
```

---

### End of array

```
Remaining elements â†’ NGE = -1
```

âœ… Final result:

```
[5, 10, 10, -1, -1]
```

---

# 8ï¸âƒ£ Why This Works (Core Logic)

Each element is:

* **Pushed once**
* **Popped once**

So:

```
Total operations = O(n)
```

This is the magic of monotonic stacks.

---

# 9ï¸âƒ£ Java Implementation (Index-based â€“ Interview Friendly)

```java
public int[] nextGreaterElements(int[] arr) {
    int n = arr.length;
    int[] nge = new int[n];
    Arrays.fill(nge, -1);

    Stack<Integer> stack = new Stack<>(); // stores indices

    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {
            int idx = stack.pop();
            nge[idx] = arr[i];
        }
        stack.push(i);
    }

    return nge;
}
```

---

# ğŸ”Ÿ Why Store Indices Instead of Values?

Because:

* We need to **update result array**
* Indices let us map values back to positions

---

# 1ï¸âƒ£1ï¸âƒ£ Pattern Recognition (Very Important for Interviews)

| Problem                | Stack Type               |
| ---------------------- | ------------------------ |
| Next Greater Element   | Monotonic **Decreasing** |
| Next Smaller Element   | Monotonic **Increasing** |
| Previous Greater       | Reverse traversal        |
| Stock Span             | Decreasing               |
| Largest Histogram Area | Increasing               |

---

# 1ï¸âƒ£2ï¸âƒ£ One-Line Memory Trick ğŸ§ 

> **â€œIf Iâ€™m looking for something greater â†’ keep stack decreasing.â€**
> **â€œIf Iâ€™m looking for something smaller â†’ keep stack increasing.â€**

---

# 1ï¸âƒ£3ï¸âƒ£ Common Interview Follow-ups

* Circular NGE â†’ traverse array twice (`i % n`)
* Previous Greater â†’ traverse from **right to left**
* Count days / distances â†’ store indices
* Handle duplicates â†’ use `<=` vs `<` carefully

---
