SKYLINE PROBLEM - VISUAL WALKTHROUGH & INTERVIEW GUIDE
=======================================================

PROBLEM VISUALIZATION
=====================

Given: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]

Step-by-step visualization:

Position:  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
          ┌──────────────────────────────────────────────────────────────────┐
Height 15 │     ┌────────┐                                                   │
          │     │        │                                                   │
Height 12 │     │        └─────────┐                                         │
          │     │                  │                                         │
Height 10 │  ┌──┘                  └──┐        ┌─────────┐                   │
          │  │                        │        │         │                   │
Height 8  │  │                        │        │         └──┐                │
          │  │                        │        │            └────────┐       │
Height 0  └──┴────────────────────────┴────────┴─────────────────────┴───────┘
          0  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24

Key Points (where height changes):
- At x=2:  height goes 0→10  → Point [2, 10]
- At x=3:  height goes 10→15 → Point [3, 15]
- At x=7:  height goes 15→12 → Point [7, 12]
- At x=12: height goes 12→0  → Point [12, 0]
- At x=15: height goes 0→10  → Point [15, 10]
- At x=20: height goes 10→8  → Point [20, 8]
- At x=24: height goes 8→0   → Point [24, 0]

Answer: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]


ALGORITHM WALKTHROUGH - SWEEP LINE APPROACH
============================================

STEP 1: Create Events
----------------------
For each building [left, right, height], create:
- Start event: [left, -height]  (negative to differentiate)
- End event: [right, height]    (positive)

Buildings:
[2,9,10]   → Events: [2, -10], [9, 10]
[3,7,15]   → Events: [3, -15], [7, 15]
[5,12,12]  → Events: [5, -12], [12, 12]
[15,20,10] → Events: [15, -10], [20, 10]
[19,24,8]  → Events: [19, -8], [24, 8]

All events: [2,-10], [9,10], [3,-15], [7,15], [5,-12], [12,12], [15,-10], [20,10], [19,-8], [24,8]


STEP 2: Sort Events
-------------------
Sort by x-coordinate, then by height (with special rules)

Sorted events:
[2, -10]   <- Building starts at x=2, height 10
[3, -15]   <- Building starts at x=3, height 15
[5, -12]   <- Building starts at x=5, height 12
[7, 15]    <- Building ends at x=7, height 15
[9, 10]    <- Building ends at x=9, height 10
[12, 12]   <- Building ends at x=12, height 12
[15, -10]  <- Building starts at x=15, height 10
[19, -8]   <- Building starts at x=19, height 8
[20, 10]   <- Building ends at x=20, height 10
[24, 8]    <- Building ends at x=24, height 8


STEP 3: Process Events with Active Heights Tracking
----------------------------------------------------

Initial state:
- heightMap = {0: 1}  (ground level always present)
- prevMaxHeight = 0
- result = []

Event 1: [2, -10] (START, height 10)
  Action: Add height 10 to heightMap
  heightMap = {0: 1, 10: 1}
  currentMaxHeight = 10
  Change? Yes (0 → 10)
  Add to result: [2, 10]
  prevMaxHeight = 10

Event 2: [3, -15] (START, height 15)
  Action: Add height 15 to heightMap
  heightMap = {0: 1, 10: 1, 15: 1}
  currentMaxHeight = 15
  Change? Yes (10 → 15)
  Add to result: [3, 15]
  prevMaxHeight = 15

Event 3: [5, -12] (START, height 12)
  Action: Add height 12 to heightMap
  heightMap = {0: 1, 10: 1, 12: 1, 15: 1}
  currentMaxHeight = 15
  Change? No (15 → 15, building 12 is hidden)
  Nothing added
  prevMaxHeight = 15

Event 4: [7, 15] (END, height 15)
  Action: Remove height 15 from heightMap
  heightMap = {0: 1, 10: 1, 12: 1}
  currentMaxHeight = 12
  Change? Yes (15 → 12)
  Add to result: [7, 12]
  prevMaxHeight = 12

Event 5: [9, 10] (END, height 10)
  Action: Remove height 10 from heightMap
  heightMap = {0: 1, 12: 1}
  currentMaxHeight = 12
  Change? No (12 → 12)
  Nothing added
  prevMaxHeight = 12

Event 6: [12, 12] (END, height 12)
  Action: Remove height 12 from heightMap
  heightMap = {0: 1}
  currentMaxHeight = 0
  Change? Yes (12 → 0)
  Add to result: [12, 0]
  prevMaxHeight = 0

Event 7: [15, -10] (START, height 10)
  Action: Add height 10 to heightMap
  heightMap = {0: 1, 10: 1}
  currentMaxHeight = 10
  Change? Yes (0 → 10)
  Add to result: [15, 10]
  prevMaxHeight = 10

Event 8: [19, -8] (START, height 8)
  Action: Add height 8 to heightMap
  heightMap = {0: 1, 8: 1, 10: 1}
  currentMaxHeight = 10
  Change? No (10 → 10, building 8 is hidden)
  Nothing added
  prevMaxHeight = 10

Event 9: [20, 10] (END, height 10)
  Action: Remove height 10 from heightMap
  heightMap = {0: 1, 8: 1}
  currentMaxHeight = 8
  Change? Yes (10 → 8)
  Add to result: [20, 8]
  prevMaxHeight = 8

Event 10: [24, 8] (END, height 8)
  Action: Remove height 8 from heightMap
  heightMap = {0: 1}
  currentMaxHeight = 0
  Change? Yes (8 → 0)
  Add to result: [24, 0]
  prevMaxHeight = 0

FINAL RESULT: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]] ✓


TRICKY EDGE CASES EXPLAINED
============================

Edge Case 1: Buildings at Same X-Coordinate
--------------------------------------------
Input: [[0,2,3],[0,2,4]]

Events before sorting: [0,-3], [2,3], [0,-4], [2,4]
After sorting: [0,-4], [0,-3], [2,3], [2,4]

Why -4 before -3? Because we want TALLER buildings first at same x.
This prevents intermediate key point at lower height.

Processing:
[0,-4]: heightMap={0:1, 4:1}, max=4, add [0,4]
[0,-3]: heightMap={0:1, 3:1, 4:1}, max=4, no change
[2,3]:  heightMap={0:1, 4:1}, max=4, no change
[2,4]:  heightMap={0:1}, max=0, add [2,0]

Result: [[0,4],[2,0]] ✓

If we didn't sort properly, we might get: [[0,3],[0,4],[2,0]] ✗ (wrong!)


Edge Case 2: Adjacent Buildings Same Height
--------------------------------------------
Input: [[0,2,3],[2,5,3]]

Events: [0,-3], [2,3], [2,-3], [5,3]
After sorting: [0,-3], [2,-3], [2,3], [5,3]

Processing:
[0,-3]: heightMap={0:1, 3:1}, max=3, add [0,3]
[2,-3]: heightMap={0:1, 3:2}, max=3, no change (count increases to 2)
[2,3]:  heightMap={0:1, 3:1}, max=3, no change (count decreases to 1)
[5,3]:  heightMap={0:1}, max=0, add [5,0]

Result: [[0,3],[5,0]] ✓

The building continues at same height, no dip!


Edge Case 3: Smaller Building Inside Larger
--------------------------------------------
Input: [[0,5,3],[1,3,5]]

Events: [0,-3], [5,3], [1,-5], [3,5]
After sorting: [0,-3], [1,-5], [3,5], [5,3]

Processing:
[0,-3]: heightMap={0:1, 3:1}, max=3, add [0,3]
[1,-5]: heightMap={0:1, 3:1, 5:1}, max=5, add [1,5]
[3,5]:  heightMap={0:1, 3:1}, max=3, add [3,3]
[5,3]:  heightMap={0:1}, max=0, add [5,0]

Result: [[0,3],[1,5],[3,3],[5,0]] ✓

The skyline "pops up" and "drops back" correctly!


INTERVIEW TALKING POINTS
=========================

When explaining your approach:

1. "This is a sweep line algorithm problem where we process events chronologically."

2. "The key insight is that the skyline height only changes at building boundaries,
   so we don't need to check every x-coordinate."

3. "At any position, the skyline height equals the maximum height among all active
   buildings. So we need a data structure to efficiently track this maximum."

4. "I'm using a TreeMap because it gives us O(log n) insertion, deletion, and 
   maximum-finding, plus it handles duplicate heights with a count."

5. "The tricky part is handling buildings that start/end at the same x-coordinate.
   We use negative heights for starts to differentiate them and ensure proper sorting."

6. "For the sorting: when x-coordinates are equal, we want starts before ends 
   (to avoid dips), and among starts, taller before shorter (to avoid intermediate points)."


TIME COMPLEXITY BREAKDOWN
==========================

1. Creating events: O(n) where n = number of buildings
   - Each building creates 2 events

2. Sorting events: O(n log n)
   - We have 2n events to sort

3. Processing events: O(n log n)
   - Each event: TreeMap insert/delete is O(log n)
   - n events total: O(n log n)

Total: O(n log n)


SPACE COMPLEXITY BREAKDOWN
===========================

1. Events list: O(n)
   - Storing 2n events

2. TreeMap: O(n)
   - In worst case, all buildings active simultaneously

3. Result list: O(n)
   - At most 2n key points

Total: O(n)


COMMON MISTAKES AND HOW TO AVOID THEM
======================================

Mistake 1: Using Set instead of Map for heights
❌ Set<Integer> heights = new TreeSet<>();
✓ TreeMap<Integer, Integer> heightMap = new TreeMap<>();

Why? Multiple buildings can have the same height! We need to count occurrences.

Mistake 2: Not initializing heightMap with 0
❌ TreeMap<Integer, Integer> heightMap = new TreeMap<>();
✓ heightMap.put(0, 1);

Why? When all buildings end, we need to return to ground level (height 0).

Mistake 3: Incorrect event sorting
❌ events.sort((a, b) -> a[0] - b[0]);
✓ events.sort((a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);

Why? When x-coordinates are same, order matters!

Mistake 4: Not checking if height actually changed
❌ result.add(Arrays.asList(x, currentMaxHeight));
✓ if (currentMaxHeight != prevMaxHeight) { ... }

Why? Avoids duplicate points when max height doesn't change.

Mistake 5: Using positive heights for all events
❌ events.add(new int[]{left, height});
✓ events.add(new int[]{left, -height});

Why? Need to differentiate starts from ends for proper sorting!


PRACTICE VARIATIONS
====================

Once you master this, try these variations:

1. Return the total visible perimeter of all buildings
2. Find the maximum gap in the skyline
3. 3D version: buildings have (x1,y1) and (x2,y2) corners
4. Dynamic version: buildings can be added/removed in real-time
5. Find the building that contributes most to the skyline


FINAL TIPS FOR INTERVIEW SUCCESS
=================================

✓ Draw the example - visual representation helps immensely
✓ Start with brute force to show understanding
✓ Explain why sweep line is better (only check critical points)
✓ Walk through a small example step-by-step
✓ Test with edge cases (overlapping, adjacent, same height)
✓ Explain time/space complexity clearly
✓ Mention alternative approaches (divide-and-conquer)
✓ Stay calm - this is a HARD problem, partial credit counts!

