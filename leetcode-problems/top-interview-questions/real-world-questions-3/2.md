# ðŸ”¥ 2ï¸âƒ£ Distributed Message Deduplication (Global Exactly-Once)

## ðŸ§¾ Problem Statement

You are building a distributed message processing system.

Multiple servers receive messages in the form:

```
(messageId, timestamp, payload)
```

### System Properties

* Messages may arrive at **any server**
* The same `messageId` may be delivered multiple times
* Network retries may cause duplicates
* Servers may crash and restart
* Messages may arrive out of order
* System runs continuously

---

## ðŸŽ¯ Requirement

Each **unique messageId must be processed exactly once globally.**

That means:

* If a message is delivered multiple times â†’ process only once.
* If it arrives on different servers â†’ still process only once.
* If a server crashes after processing but before responding â†’ must not reprocess incorrectly.
* System must work under high throughput.

---

## âš ï¸ Constraints

* System is distributed (multiple nodes)
* No single machine sees all messages
* Memory is limited
* Throughput is high
* You may use external storage (e.g., distributed KV store)
* Exactly-once guarantee is required (not at-least-once)

---

## ðŸ§  Clarifications You Should Ask in Interview

1. Are messageIds globally unique?
2. Can we rely on external storage (e.g., Redis, DB, Kafka)?
3. Is slight latency acceptable?
4. Do we need strong consistency?
5. Is message processing idempotent?
6. Do messageIds expire eventually?

---

## ðŸ’¡ What This Problem Is Really Testing

* Idempotency design
* Distributed coordination
* Consistency vs availability tradeoffs
* Dedup storage design (TTL-based)
* Crash recovery correctness
* Exactly-once semantics vs at-least-once
* Bloom filter memory optimization (optional advanced)

---

## ðŸ“¦ Example

Server A receives:

```
(M123, 10:00:00)
```

Processes it.

Then Server B receives:

```
(M123, 10:00:01)
```

It must detect duplicate and skip.

---

If Server A crashes after processing but before marking completion, system must still guarantee correctness.

---

This is a classic Google L5 distributed systems question.

When youâ€™re ready, weâ€™ll start solving it step by step:

1ï¸âƒ£ Naive approach
2ï¸âƒ£ Single-node solution
3ï¸âƒ£ Distributed extension
4ï¸âƒ£ Crash recovery
5ï¸âƒ£ Strong consistency design
6ï¸âƒ£ Performance optimizations
7ï¸âƒ£ Bloom filter memory optimization
8ï¸âƒ£ Tradeoff discussion

---

Excellent.
Now weâ€™re entering **true L5 distributed systems territory**.

This is not a hashmap problem anymore. This is about **exactly-once semantics under failure**.

---

# ðŸ”¥ 2ï¸âƒ£ Distributed Message Deduplication (Global Exactly-Once)

---

# ðŸ§  Step 1: Clarify the Real Requirement

We must guarantee:

> Each unique `messageId` is processed exactly once globally, even with:

* Retries
* Multiple servers
* Crashes
* Network partitions

Important distinction:

| Guarantee     | Meaning                    |
| ------------- | -------------------------- |
| At-least-once | Might process duplicates   |
| At-most-once  | Might drop messages        |
| Exactly-once  | Process once and only once |

Exactly-once is the hardest.

---

# ðŸ§  Step 2: Naive Approach (Wrong)

Each server keeps:

```
Set<messageId>
```

Before processing:

* If in set â†’ skip
* Else process + add to set

âŒ Problem:

* Servers don't share memory
* Duplicates across nodes not detected
* Crash loses memory

Rejected.

---

# ðŸ§  Step 3: First Correct Direction

We need **shared durable state**.

So idea becomes:

Before processing:

```
Check in distributed store:
  If messageId already processed â†’ skip
  Else mark as processed â†’ then process
```

But careful.

This naive distributed version still has race conditions.

---

# ðŸ§  Step 4: Race Condition Problem

Two servers:

Server A and Server B both receive same message simultaneously.

Both check store:

```
not found
```

Both proceed.

Now duplicate processed.

We need atomicity.

---

# ðŸ§  Step 5: Atomic "Claim" Operation

We need something like:

```
SETNX(messageId, PROCESSING)
```

(SET if Not Exists)

Atomic.

If succeeds â†’ this server owns it
If fails â†’ someone else is handling it

This is the core trick.

In Redis:

```
SET key value NX EX ttl
```

In DB:

```
INSERT with unique constraint
```

In DynamoDB:

```
Conditional write
```

---

# ðŸ§  Step 6: But We Still Have Crash Problem

What if:

1. Server claims message
2. Processes it
3. Crashes before marking "done"

Then:

* Store says PROCESSING
* Message never marked complete
* Retries blocked forever

We need state machine.

---

# ðŸ§  Step 7: Proper State Machine Design

Instead of boolean, store:

```
messageId â†’ {
    status: PROCESSING | DONE
    updatedAt: timestamp
}
```

Flow:

### Step 1: Try to insert record

If not exists:

```
INSERT messageId, PROCESSING
```

### Step 2: Process message

### Step 3: Mark as DONE

---

Now consider crash scenarios.

---

# ðŸ§  Step 8: Crash Handling

Case 1:
Crash before marking DONE.

Store shows:

```
PROCESSING
```

Now when retry happens:

We check:

* If PROCESSING and too old (timeout exceeded)
* Then assume previous worker crashed
* Retry processing

This requires TTL logic.

---

# ðŸ§  Step 9: Full Algorithm

On message receive:

```
1. Try atomic insert (messageId, PROCESSING, now)
   If fails:
       Fetch existing record
       If status == DONE â†’ skip
       If status == PROCESSING:
            If expired â†’ attempt takeover
            Else â†’ skip

2. Process message

3. Update status to DONE
```

---

# ðŸ§  Step 10: Storage Options

### Option 1: Redis

Pros:

* Fast
* TTL support
* SETNX atomic

Cons:

* Needs persistence config for crash recovery

---

### Option 2: SQL DB with Unique Index

```
CREATE TABLE processed_messages (
    message_id VARCHAR PRIMARY KEY,
    status VARCHAR,
    updated_at TIMESTAMP
);
```

Use:

```
INSERT ... ON CONFLICT DO NOTHING
```

Strong consistency.

---

### Option 3: Kafka Transactional Producer (Advanced)

Kafka supports:

* Idempotent producers
* Exactly-once processing using offsets + transactions

But that's deeper infra-level.

---

# ðŸ§  Step 11: Exactly-Once vs Idempotent Processing

Important insight:

In real systems:

True exactly-once is often achieved by:

> Making processing idempotent.

For example:
If message means:

```
Add $100 to account
```

We instead:

```
Set transactionId = M123
Only apply if not applied before
```

Which reduces problem complexity.

---

# ðŸ§  Step 12: Memory Optimization (Advanced)

If system processes billions of messages:

We cannot store messageIds forever.

Use TTL:

Keep only for:

* Max retry window (e.g., 24h)

After TTL expires â†’ delete.

Now memory bounded.

---

# ðŸ§  Step 13: Bloom Filter Optimization (Optional Advanced)

If:

* Very high throughput
* Memory constrained

We can:

* Use Bloom filter for quick rejection
* Then verify in DB

Tradeoff:
False positives possible (may skip valid message)

So only acceptable if rare.

---

# ðŸ§  Step 14: Consistency vs Availability

If using strongly consistent DB:

* Correctness high
* Latency slightly higher

If using eventually consistent store:

* Possible duplicates
* Faster

For exactly-once:
We prefer strong consistency.

---

# ðŸ§  Step 15: Java Pseudocode

```java
public void handleMessage(Message msg) {

    boolean inserted = repository.tryInsertProcessing(msg.getMessageId());

    if (!inserted) {
        MessageStatus status = repository.getStatus(msg.getMessageId());

        if (status == DONE) {
            return; // already processed
        }

        if (status == PROCESSING && !repository.isExpired(msg.getMessageId())) {
            return; // someone else processing
        }

        repository.forceTakeover(msg.getMessageId());
    }

    try {
        process(msg);
        repository.markDone(msg.getMessageId());
    } catch (Exception e) {
        // leave as PROCESSING, will retry later
        throw e;
    }
}
```

---

# ðŸ§  Step 16: What Google Is Really Testing

This question tests:

* Distributed coordination
* Atomic conditional writes
* Failure recovery
* State machines
* TTL expiration correctness
* Idempotency reasoning
* Consistency tradeoffs

---

# ðŸ§  Riyaz-Level Interview Framing

You should say something like:

> "We achieve global exactly-once by using an atomic conditional insert into a strongly consistent store. We treat dedup entries as a state machine with PROCESSING and DONE states, and we handle crash recovery via expiry-based takeover logic."

That sounds L5.

---
